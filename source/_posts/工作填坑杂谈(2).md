---
title: 工作中填坑杂谈(2)
date: 2017-08-28 23:10:54
categories: 遇到的坑
tags:
     - 填坑经验
description: 记录工作中踩到的坑，无序。。。
---
## Java抛出ConcurrentModificationException异常的原因
Java中的Map如果在遍历过程中要删除元素，除非通过迭代器自己的remove()方法，否则就会导致抛出ConcurrentModificationException异常。
这么做的原因是为了保证迭代器能够尽快感知到Map的“结构性修改“，从而避免不同视图下不一致现象。
## 实现一个按首字母分组的通讯录名单
思想：创建一个分类数组，依次遍历数组和数据对象，将数据分类。
代码如下：
```
    /**
     * getAddressBookForMoblie:安卓手机获取通讯录用户接口
     *
     * @author yijin
     * @since JDK 1.8
     */
    public void getAddressBookForMoblie() {
        HttpServletRequest request = ServletActionContext.getRequest();
        String token = request.getParameter("token");
        IrpUser irpuser = mobileAction.getlogin(token);
        Long userid = irpuser.getUserid();

        // 查询用户数量
        int result = irpUserService.findUserbySMcount("", null);

        // 创建分页对象
        PageUtil pageUtil = new PageUtil(this.pageNum, this.pageSizeclient, result);

        // 查询所有通讯录用户
        List<IrpUser> irpUsers = irpUserService.findUserbySM("", null, pageUtil);

        // 存放分类数据的集合
        List<Map<String, Object>> dataList = new ArrayList<Map<String, Object>>();

        // 获得当前登录用户所关注的用户列表
        List irpMicroblogFocuslist = this.irpMicroblogFocusService.selectUseridByLoginuserId(userid);

        // 创建一个以大写字母为键的集合
        Map<String, List<Map<String, Object>>> initialMap = new HashMap<String, List<Map<String, Object>>>();

        // 创建一个用于分类的字母数组
        String[] words = { "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R",
                "S", "T", "U", "V", "W", "X", "Y", "Z" };

        for (String word : words) {
            for (int i = 0; i < irpUsers.size(); i++) {
                // 如果用户名的首字母等于一个字母，将其填入集合
                if (word.equals(irpUsers.get(i).getUsersm())) {
                    // 存放头像、名称、关注信息和id等相关用户信息
                    Map<String, Object> userMap = new HashMap<String, Object>();

                    userMap.put("addrebookphone", irpUsers.get(i).getMobile());
                    userMap.put("addrebooksex", irpUsers.get(i).getSex());
                    userMap.put("addrebookmail", irpUsers.get(i).getEmail());
                    userMap.put("addrebookarea", irpUsers.get(i).getLocation());

                    if (irpUsers.get(i).getUserpic() != null) {
                        // 头像不为空给头像加token
                        userMap.put("addrebookimg", irpUsers.get(i).getUserpic() + "&token="
                                + irpUsers.get(i).getToken());
                    } else {
                        //给默认头像
                        userMap.put("addrebookimg", irpUsers.get(i).getDefaultUserPic());
                    }

                    // 名称
                    userMap.put("addrebookname", irpUsers.get(i).getTruename());

                    // id
                    userMap.put("addrebookuserid", irpUsers.get(i).getUserid());

                    // 当前登录用户所关注的用户列表中是否存在遍历的用户，如果有设为1（关注）
                    if (irpMicroblogFocuslist.contains(irpUsers.get(i).getUserid().toString())) {
                        userMap.put("addrebookattentionstatus", "1");
                    } else {
                        userMap.put("addrebookattentionstatus", "0");
                    }

                    // 把map放入分类数据的集合中
                    dataList.add(userMap);
                }
            }
            // 放入以字母为键的集合中
            initialMap.put(word, dataList);
            // 置空
            dataList = new ArrayList<Map<String, Object>>();
        }

        // 遍历map将空的集合移除
        Iterator<Map.Entry<String, List<Map<String, Object>>>> map = initialMap.entrySet().iterator();
        while(map.hasNext()){
            Map.Entry<String, List<Map<String, Object>>> entry = map.next();
            if(entry.getValue().isEmpty()){
                map.remove();//使用迭代器的remove()方法删除元素
            }
        }
        ActionUtil.writer(JsonUtil.map2json(initialMap));
    }
```

## js函数通过回调函数来返回ajax获得的数据
在跨域的ajax请求中，async属性是失效的，所以想通过函数返回ajax获取的服务端数据就只能使用回调函数，具体实例如下：
```
function test(callback){
    jQuery.ajax({
        url:"...",
        method:"GET",
        data:{},
        success:function(data){
            callback(data);
        }
    });
}

test(function(data){
    alert(data);
});
```


## 使用Oracle导入.imp和.bmp文件
1. 创建表空间，创建用户(都是大写)选择表空间，分配DBA CONNECT RESOURCE权限。
2. 在开始菜单中输入cmd ,不需要切换到sqlplus。
3. 命令：imp 用户名/密码@服务器地址:数据库端口号/数据库 file=路径 full=y
full=y表示将数据库表全部导入。

## 删除限定日期之前的Sql语句
DELETE
FROM
    表名
WHERE
    日期字段 < TO_DATE (
        '2015-01-01 00:00:00',
        'yyyy-mm-dd HH24:MI:SS'
    );

> 注：Oracle中HH24表示24小时制，MI表示分。

## 恢复MyEclipse不小心弄错乱的界面
菜单栏window->Reset perspective

## Solr中的日期格式
Solr中的日期有很严格的格式限制： YYYY-MM-DDThh:mm:ssZ
YYYY：表示年   MM：表示月份   DD：表示天
hh：表示小时，24小时制   mm：表示分钟   ss：表示秒钟
Z 代表时区是UTC

## Java中为Solr搜索添加过滤条件
SolrQuery.addFilterQuery(String str);
例如：
```
// 表示时间范围是2015-01-01之后
SolrQuery.addFilterQuery("CRTIME:[2015-01-01T00:00:00Z TO *]");
```

## Java异常：Error: executeQueryForObject returned too many results. 的解决方法
ibatis封装的操作数据库的对象中QueryForObject方法返回的是一个对象，如果有多个对象的话，就会报异常。
如果有多条返回结果，不应该用executeQueryForObject，应该用executeForObjectList或者queryForList。

## Java中的Map结构，根据value值进行排序
```
// 将userIdMap转换为List，以便排序
List<Map.Entry<Integer, Integer>> sortList = new ArrayList<Map.Entry<Integer, Integer>>(userIdMap.entrySet());

// 通过比较器来实现排序(降序)
Collections.sort(sortList, new Comparator<Map.Entry<Integer, Integer>>() {
    @Override
    public int compare(Entry<Integer, Integer> o1, Entry<Integer, Integer> o2){
        return o2.getValue().compareTo(o1.getValue());
    }
});
```
