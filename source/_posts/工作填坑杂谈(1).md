---
title: 工作中填坑杂谈(1)
date: 2017-08-07 21:10:54
categories: 遇到的坑
tags:
     - 填坑经验
description: 记录工作中踩到的坑，无序。。。
---
## 通过$.ajax({}).responseText获得返回的URL来获取URL指向页面的HTML代码
实际开发中我们有时候需要通过切换不同的页面来达到不同的效果，我们可以通过ajax异步访问一个controller，在这个controller中最后返回一个指向页面的URL地址，那么我们就可以用$.ajax({}).responseText来获取URL地址中页面的HTML代码来追加到当前页面。
## 序列化input输入框或者是表单
jQuery的serialize()方法可以序列化表单值，来创建URL编码的文本字符串，序列化的值可在 AJAX 请求时用于 get方式传参。
可以选择一个或多个表单元素（比如 input 及/或 文本框），或者 form 元素本身。
使用方法：$(元素).serialize();

>注：**serialize()会自动调用encodeURIComponent方法对数据进行编码** 

## 使用MyEclipse打开框架配置文件时卡死，有可能是因为文件默认打开方式不对
XML配置文件的打开方式不要用MyEclipse自带的。
## CSS行内元素的特征
诸如像span、a等这些行内元素，使用margin-top、margin-bottom、padding-top、padding-bottom、width、height等是无效的，只能设置left和right。如果想让这些属性生效，要添加display:inline-block。
display:inline-block:使元素成为行内块元素。
## jQuery的parents()的用法
通过Element.parents()获取元素所有的祖先元素，并用find()找到自己想要的元素。
## jQuery的remove()的用法
使用Element.remove()把元素自身移除，同时也会移除元素内部的一切，包括绑定的事件以及与该元素相关的数据。
## js中字符串转换为数字
parseInt(string)
## 在实现一个通讯录模块时需要将中文转换为拼音
中文转拼音的使用找到了一个pinyin.js。
## js对象根据字段排序
示例：
```
json.sort(function(a,b){
    if(a.value < b.value){
        return -1;
    }else if(a.value > b.value){
        return 1;
    }else{
        return 0;
    }
});
```
## CSS属性pointer-events
设置pointer-events:none; 时元素永远不会成为鼠标事件的target。但是，当其后代元素的pointer-events属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下，鼠标事件将在捕获或冒泡阶触发父元素的事件侦听器。
## MyEclipse项目部署时不能自动部署jar时的处理方法
在项目根目录点击右键之后选择build path，找到deployment assembly(部署程序集)，进行手动添加jar包。
## CSS设置内容溢出显示省略号
```
/* 行内容溢出显示省略号 */
overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;

/* 多行显示省略号 */
display:-webkit-box; // 弹性盒子
-webkit-box-orient:vertical // 从上到下垂直排列子元素
-webkit-line-clamp:3 // 显示行数
overflow:hidden // 超出部分隐藏
```
## CSSflex布局
http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html
## CSS伪类active的使用
在WebAPP中为列表和需要点击的Dom对象添加active伪类，使其在点击时能产生高亮效果，接近原生APP体验。
## 移动端APP实现双击手机返回键退出
以APPCan平台为例：

```
// 初始化需要用的变量
var currentTime, firstTime, secondTime, clickCount = 0;
// 如果按了手机上的返回键，就退出程序
uexWindow.onKeyPressed = function(k) {
    if (k == 0) {
        // 点击次数加1
        clickCount++;
        appcan.window.openToast("再按一次可退出程序", 1000, '8', '0');
        // 获得时间
        currentTime = new Date();
        // 点击了一次
        if (clickCount == 1) {
            firstTime = currentTime.getTime();
        } else if (clickCount == 2) { // 第二次点击
            secondTime = currentTime.getTime();
            // 两秒之内连续按才能退出应用程序
            if (secondTime - firstTime < 2000) {
                uexWidgetOne.exit(1);
            } else {
                clickCount = 0;
            }
        } else {
            clickCount = 0; // 点击次数大于2时置为0
        }
    }
};
// 监听物理返回键并拦截返回键(0)
uexWindow.setReportKey(0, 1);
```